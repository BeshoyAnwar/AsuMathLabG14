// My_Phase2_Function.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"


#include <iostream>
#include <string>
#include <algorithm>
#include <sstream>
#include <math.h>

using namespace std;


bool isFloat(string myString) 
{
	istringstream iss(myString);
	double f;
	iss >> noskipws >> f; // noskipws considers leading whitespace invalid
						  // Check the entire string was consumed and if either failbit or badbit is set
	return iss.eof() && !iss.fail();
}

bool isComplex(string mystring)
{
	std::size_t found = mystring.find_first_of("ij");
	if (found == std::string::npos)
	{
		return false;
	}
	return true;
}


void defMat(string s, string varNames[100], string varContent[100], int& variablesNo)
{

	string array[100], text, token, replace, value;
	size_t Equal_pos, found_var, found_par1, diff, found_par2, semi_colon, semi_colon_2, semi_colon_no, colon, token2_pos, final_semi_colon;
	int flag = 0, c = 0, replaced_pos, Equal_no;
	string name;

	//sort(varNames, varNames + variablesNo - 1);
	Equal_no = count(s.begin(), s.end(), '=');


	//cout << "variablesNo :" << variablesNo << endl;
	final_semi_colon = s.find_first_of(";", s.find_last_of("]"));
	if (final_semi_colon != string::npos)s.erase(final_semi_colon, 1);
	//cout << s << endl;

	// Replace The Variable in all matrix By it's Value

	for (int i = variablesNo; i >= 0; i--)
	{
		for (int count = variablesNo; count >= 0; count--)
		{
			found_var = varContent[i].find(varNames[count]);
			//cout << found_var << endl;
			while (found_var != string::npos)
			{
				//cout << "first 'var' found at: " << found_var << '\n';
				varContent[i].replace(found_var, varNames[count].length(), varContent[count]);
				//cout << varContent[i] << endl;
				found_var = varContent[i].find(varNames[i], found_var + 1);
			}
		}
	}
	/*
	for (int i = 0; i < variablesNo; i++)
	{
	istringstream iss4(varContent[i]);
	cout << "start" << endl;
	while (getline(iss4, token, ' '))
	{
	cout << token << endl;
	if (!isFloat(token))
	{
	token2_pos = varContent[i].find(token);
	for (int i = variablesNo; i >= 0; i--)
	{
	if (token.compare(varnames[i]) != 0)
	{
	value = varContent[i];
	cout << value << endl;
	}
	}
	varContent[i].replace(token2_pos, token.length(), value);
	}
	}
	cout << "end" << endl;

	}*/
	Equal_pos = s.find_first_of('=');
	// Replace The Variable in s By it's Value
	for (int i = variablesNo; i >= 0; i--)
	{
		found_var = s.find(varNames[i], Equal_pos);
		while (found_var != string::npos)
		{
			//cout << "first 'var' found at: " << found_var << '\n';
			s.replace(found_var, varNames[i].length(), varContent[i]);
			found_var = s.find(varNames[i], found_var + 1);
		}
	}
	//	cout << "first: " << s << endl;
	//more than one variable have the same content a=b=...
	for (int b = 0; b < Equal_no; b++)
	{
		Equal_pos = s.find_first_of('=');
		varNames[variablesNo] = s.substr(0, Equal_pos);
		//remove_if(varNames[variablesNo].begin(), varNames[variablesNo].end(), isspace);
		varNames[variablesNo].erase(remove_if(varNames[variablesNo].begin(), varNames[variablesNo].end(), isspace), varNames[variablesNo].end());
		name = varNames[variablesNo];

		s.erase(0, Equal_pos + 1);
		variablesNo++;
		//string::iterator end_pos = remove(varNames[variablesNo].begin(), varNames[variablesNo].end(), ' ');
		//varNames[variablesNo].erase(end_pos, varNames[variablesNo].end());
		//cout <<varNames[variablesNo];
	}
	//cout << "variablesNo :" << variablesNo << endl;
	//cout << s << endl;

	// parsing '[' to ']'
	if (s.find_first_of("[") != string::npos&&s.find_last_of("]") != string::npos)
	{
		s.erase(s.find_first_of("["), 1);
		s.erase(s.find_last_of("]"), 1);
		//cout << "erase :" << s << endl;
		/*istringstream iss3(s);
		//cout << "start" << endl;
		while (getline(iss3, token, ' '))
		{
		cout << token << endl;
		if (!isFloat(token))
		{
		token2_pos = s.find(token);
		for (int i = variablesNo; i >= 0; i--)
		{
		if (token.compare(varnames[i]) != 0)
		{
		value = varContent[i];
		cout << value << endl;
		}
		}
		s.replace(token2_pos, token.length(), value);
		}
		}
		cout << "end" << endl;*/
		//cout << s << endl;


		found_par1 = s.find_first_of("[");
		found_par2 = s.find_first_of("]");

		//cout << s << endl;
		while (found_par1 != string::npos&& found_par2 != string::npos)
		{

			//cout<<found_par1<<" "<<found_par2<<endl;

			semi_colon = s.find(";", found_par1);
			colon = s.find_first_of(",", found_par1);
			//cout<<semi_colon<<endl;
			//if there is semi-colon between the two braces []
			if (found_par1 < semi_colon&&semi_colon < found_par2)
			{
				//	cout<<count_1<<endl;
				//	if(count_1==0)
				if (flag == 0) {
					replaced_pos = found_par1; flag = 1;
				}
				text = s.substr(found_par1 + 1, found_par2 - found_par1 - 1);
				istringstream iss(text);
				//cout<<text<<endl;
				semi_colon_no = count(s.begin() + found_par1, s.begin() + found_par2, ';');
				//	cout<<semi_colon_no<<endl;
				//save value inside [] in an array
				for (size_t i = 0; i <= semi_colon_no; i++)
				{
					getline(iss, token, ';');
					array[c] += " " + token;
					c++;

				}

				//cout<<array[0]<<";"<<array[1]<<endl;


				colon = s.find_first_of(",", found_par2, 2);
				semi_colon_2 = s.find_first_of(";", found_par2);
				//	cout << "semi_colon_2 : " << semi_colon_2 << endl;
				diff = colon - found_par2;
				//	cout << "found_par2 : " << found_par2 << endl;
				//	diff2 = semi_colon_2 - found_par2;
				//	cout << "diff2 : " << diff2<< endl;

				//	cout<<diff<<endl;
				//if  (diff>4 || diff<0) 
				if (semi_colon_2 > 100)
				{
					for (int i = 0; i < c; i++)
					{
						if (i != c - 1)
							replace += array[i] + ";";
						else
							replace += array[i];
					}
					//cout<<"replace : "<<replace<<endl;
					s.replace(replaced_pos, found_par2 - replaced_pos + 1, replace);//replace array
																					//cout<<s<<endl;
					replace.clear();
					flag = 0;
					//cout<<replaced_pos<<endl;
					for (int i = 0; i < c; i++)
						array[i].clear();
					//cout<<array[0]<<endl;
					//empty arrray & replace	
				}
				c = 0;
			}
			else if (found_par1 < colon&&colon < found_par2)
				s.erase(colon, 1);
			else
			{
				//s.erase(found_par1, 1);
				//s.erase(found_par2 - 1, 1);
				s.erase(remove(s.begin(), s.end(), '['), s.end());
				s.erase(remove(s.begin(), s.end(), ']'), s.end());
			//	cout << "Second erase :" << s<<endl;
			}

			found_par1 = s.find_first_of("[", found_par1 + 1);
			found_par2 = s.find_first_of("]", found_par2 + 1);

		}

		istringstream iss(s);
		while (getline(iss, token, ';'))
		{
			istringstream iss2(token);
			while (getline(iss2, token, ' '))
			{
				//cout << token << endl;
				if ((!isFloat(token) && token.find_first_not_of(' ') != string::npos ) && (!isComplex(token)))
				{
					//cout << token << endl;
					token2_pos = s.find(token);
					//					doOperation(token, varNames, varContent, variablesNo);
					//s.replace(token2_pos, token.length(),token);
					s.replace(token2_pos, token.length(),"temp");
				}
			}
		}
		//cout << s << endl;
	//	s.erase(remove(s.begin(), s.end(), '['), s.end());
	//	s.erase(remove(s.begin(), s.end(), ']'), s.end());
		s = "[" + s + "]";
	}
	//else
	//{
	//s = "[" + s + "]";
	//}



	//int real = variablesNo - Equal_no;
	for (int b = 1; b <= Equal_no; b++)
	{
		varContent[variablesNo - b] = s;
		//cout<<varContent[variablesNo]<<variablesNo<<endl;
	}


	//find similar variables

	for (int i = 0; i<variablesNo; i++)
	{
		for (int j = i + 1; j<variablesNo; j++)
		{
			if (varNames[i] == varNames[j])
			{

				varContent[i] = varContent[j];
				for (int x = j; x <= variablesNo; x++)
				{
					varContent[x] = varContent[x + 1];
					varNames[x] = varNames[x + 1];
				}
				variablesNo--;
			}
		}
	}
	if (final_semi_colon == string::npos) {
		cout << "//" << name<<"//";
		//print(name, varNames, varContent, variablesNo);
	}
}// Mina Mouries /* Define matrices that contain variables like b = [1; 2] a = [5] A = a = [1 3 4 5 a sin(0.4); 3 2 3 4 [9 2]; [2 3 4 2 1; 2 3 4 5 6], b] i.e: any matrix other than special matrices defined above*/



int main()
{
	string varNames[100];
	string varContent[100];
	int variableNo = 4;
	varNames[0] = "c";
	varContent[0] = "[0.9998 1.9683 -555]";
	varNames[2] = "ce";
	varContent[2] = "[c;5.5 -7.89 x;9.65 x x]";
	varNames[1] = "x";
	varContent[1] = "5i";
	varNames[3] = "c1";
	varContent[3] = "[2.2 3.3;5.5 -7.89;9.65 x]";
	cout << varNames[2] << "=" << varContent[2] << endl;
	defMat("g                                =[ce]", varNames, varContent, variableNo);
	//cout << varNames[4]<<"="<<varContent[4] << endl;

//	defMat("o3=[[g;g;g;g] [g;g;g;g]]", varNames, varContent, variableNo);
	//cout << varNames[5] << "=" << varContent[5] << endl;

//	defMat("e=[6 4 5]", varNames, varContent, variableNo);
	for (int i = 0; i<variableNo; i++)
		cout << varNames[i] << "=" << varContent[i] << endl;
	//	defMat("g=[ce c]", varNames, varContent, variableNo);
	//cout << varNames[6] << varContent[6] << endl;
}
